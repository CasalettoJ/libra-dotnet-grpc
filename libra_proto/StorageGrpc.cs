// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: storage.proto
// </auto-generated>
// Original file comments:
// Copyright (c) The Libra Core Contributors
// SPDX-License-Identifier: Apache-2.0
//
#pragma warning disable 0414, 1591
#region Designer generated code

using grpc = global::Grpc.Core;

namespace Storage {
  /// <summary>
  /// -----------------------------------------------------------------------------
  /// ---------------- Service definition for storage
  /// -----------------------------------------------------------------------------
  /// </summary>
  public static partial class Storage
  {
    static readonly string __ServiceName = "storage.Storage";

    static readonly grpc::Marshaller<global::Storage.SaveTransactionsRequest> __Marshaller_storage_SaveTransactionsRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Storage.SaveTransactionsRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Storage.SaveTransactionsResponse> __Marshaller_storage_SaveTransactionsResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Storage.SaveTransactionsResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Types.UpdateToLatestLedgerRequest> __Marshaller_types_UpdateToLatestLedgerRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Types.UpdateToLatestLedgerRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Types.UpdateToLatestLedgerResponse> __Marshaller_types_UpdateToLatestLedgerResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Types.UpdateToLatestLedgerResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Storage.GetTransactionsRequest> __Marshaller_storage_GetTransactionsRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Storage.GetTransactionsRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Storage.GetTransactionsResponse> __Marshaller_storage_GetTransactionsResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Storage.GetTransactionsResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Storage.GetAccountStateWithProofByStateRootRequest> __Marshaller_storage_GetAccountStateWithProofByStateRootRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Storage.GetAccountStateWithProofByStateRootRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Storage.GetAccountStateWithProofByStateRootResponse> __Marshaller_storage_GetAccountStateWithProofByStateRootResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Storage.GetAccountStateWithProofByStateRootResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Storage.GetExecutorStartupInfoRequest> __Marshaller_storage_GetExecutorStartupInfoRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Storage.GetExecutorStartupInfoRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Storage.GetExecutorStartupInfoResponse> __Marshaller_storage_GetExecutorStartupInfoResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Storage.GetExecutorStartupInfoResponse.Parser.ParseFrom);

    static readonly grpc::Method<global::Storage.SaveTransactionsRequest, global::Storage.SaveTransactionsResponse> __Method_SaveTransactions = new grpc::Method<global::Storage.SaveTransactionsRequest, global::Storage.SaveTransactionsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SaveTransactions",
        __Marshaller_storage_SaveTransactionsRequest,
        __Marshaller_storage_SaveTransactionsResponse);

    static readonly grpc::Method<global::Types.UpdateToLatestLedgerRequest, global::Types.UpdateToLatestLedgerResponse> __Method_UpdateToLatestLedger = new grpc::Method<global::Types.UpdateToLatestLedgerRequest, global::Types.UpdateToLatestLedgerResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "UpdateToLatestLedger",
        __Marshaller_types_UpdateToLatestLedgerRequest,
        __Marshaller_types_UpdateToLatestLedgerResponse);

    static readonly grpc::Method<global::Storage.GetTransactionsRequest, global::Storage.GetTransactionsResponse> __Method_GetTransactions = new grpc::Method<global::Storage.GetTransactionsRequest, global::Storage.GetTransactionsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetTransactions",
        __Marshaller_storage_GetTransactionsRequest,
        __Marshaller_storage_GetTransactionsResponse);

    static readonly grpc::Method<global::Storage.GetAccountStateWithProofByStateRootRequest, global::Storage.GetAccountStateWithProofByStateRootResponse> __Method_GetAccountStateWithProofByStateRoot = new grpc::Method<global::Storage.GetAccountStateWithProofByStateRootRequest, global::Storage.GetAccountStateWithProofByStateRootResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetAccountStateWithProofByStateRoot",
        __Marshaller_storage_GetAccountStateWithProofByStateRootRequest,
        __Marshaller_storage_GetAccountStateWithProofByStateRootResponse);

    static readonly grpc::Method<global::Storage.GetExecutorStartupInfoRequest, global::Storage.GetExecutorStartupInfoResponse> __Method_GetExecutorStartupInfo = new grpc::Method<global::Storage.GetExecutorStartupInfoRequest, global::Storage.GetExecutorStartupInfoResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetExecutorStartupInfo",
        __Marshaller_storage_GetExecutorStartupInfoRequest,
        __Marshaller_storage_GetExecutorStartupInfoResponse);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::Storage.StorageReflection.Descriptor.Services[0]; }
    }

    /// <summary>Base class for server-side implementations of Storage</summary>
    [grpc::BindServiceMethod(typeof(Storage), "BindService")]
    public abstract partial class StorageBase
    {
      /// <summary>
      /// Persist transactions. Called by Execution when either syncing nodes or
      /// committing blocks during normal operation.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Storage.SaveTransactionsResponse> SaveTransactions(global::Storage.SaveTransactionsRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Used to get a piece of data and return the proof of it. If the client
      /// knows and trusts a ledger info at version v, it should pass v in as the
      /// client_known_version and we will return the latest ledger info together
      /// with the proof that it derives from v.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Types.UpdateToLatestLedgerResponse> UpdateToLatestLedger(global::Types.UpdateToLatestLedgerRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// When we receive a request from a peer validator asking a list of
      /// transactions for state synchronization, this API can be used to serve the
      /// request. Note that the peer should specify a ledger version and all proofs
      /// in the response will be relative to this given ledger version.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Storage.GetTransactionsResponse> GetTransactions(global::Storage.GetTransactionsRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      public virtual global::System.Threading.Tasks.Task<global::Storage.GetAccountStateWithProofByStateRootResponse> GetAccountStateWithProofByStateRoot(global::Storage.GetAccountStateWithProofByStateRootRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Returns information needed for Executor to start up.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Storage.GetExecutorStartupInfoResponse> GetExecutorStartupInfo(global::Storage.GetExecutorStartupInfoRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for Storage</summary>
    public partial class StorageClient : grpc::ClientBase<StorageClient>
    {
      /// <summary>Creates a new client for Storage</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      public StorageClient(grpc::Channel channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for Storage that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      public StorageClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      protected StorageClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      protected StorageClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      /// <summary>
      /// Persist transactions. Called by Execution when either syncing nodes or
      /// committing blocks during normal operation.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Storage.SaveTransactionsResponse SaveTransactions(global::Storage.SaveTransactionsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SaveTransactions(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Persist transactions. Called by Execution when either syncing nodes or
      /// committing blocks during normal operation.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Storage.SaveTransactionsResponse SaveTransactions(global::Storage.SaveTransactionsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SaveTransactions, null, options, request);
      }
      /// <summary>
      /// Persist transactions. Called by Execution when either syncing nodes or
      /// committing blocks during normal operation.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Storage.SaveTransactionsResponse> SaveTransactionsAsync(global::Storage.SaveTransactionsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SaveTransactionsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Persist transactions. Called by Execution when either syncing nodes or
      /// committing blocks during normal operation.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Storage.SaveTransactionsResponse> SaveTransactionsAsync(global::Storage.SaveTransactionsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SaveTransactions, null, options, request);
      }
      /// <summary>
      /// Used to get a piece of data and return the proof of it. If the client
      /// knows and trusts a ledger info at version v, it should pass v in as the
      /// client_known_version and we will return the latest ledger info together
      /// with the proof that it derives from v.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Types.UpdateToLatestLedgerResponse UpdateToLatestLedger(global::Types.UpdateToLatestLedgerRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return UpdateToLatestLedger(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Used to get a piece of data and return the proof of it. If the client
      /// knows and trusts a ledger info at version v, it should pass v in as the
      /// client_known_version and we will return the latest ledger info together
      /// with the proof that it derives from v.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Types.UpdateToLatestLedgerResponse UpdateToLatestLedger(global::Types.UpdateToLatestLedgerRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_UpdateToLatestLedger, null, options, request);
      }
      /// <summary>
      /// Used to get a piece of data and return the proof of it. If the client
      /// knows and trusts a ledger info at version v, it should pass v in as the
      /// client_known_version and we will return the latest ledger info together
      /// with the proof that it derives from v.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Types.UpdateToLatestLedgerResponse> UpdateToLatestLedgerAsync(global::Types.UpdateToLatestLedgerRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return UpdateToLatestLedgerAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Used to get a piece of data and return the proof of it. If the client
      /// knows and trusts a ledger info at version v, it should pass v in as the
      /// client_known_version and we will return the latest ledger info together
      /// with the proof that it derives from v.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Types.UpdateToLatestLedgerResponse> UpdateToLatestLedgerAsync(global::Types.UpdateToLatestLedgerRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_UpdateToLatestLedger, null, options, request);
      }
      /// <summary>
      /// When we receive a request from a peer validator asking a list of
      /// transactions for state synchronization, this API can be used to serve the
      /// request. Note that the peer should specify a ledger version and all proofs
      /// in the response will be relative to this given ledger version.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Storage.GetTransactionsResponse GetTransactions(global::Storage.GetTransactionsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetTransactions(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// When we receive a request from a peer validator asking a list of
      /// transactions for state synchronization, this API can be used to serve the
      /// request. Note that the peer should specify a ledger version and all proofs
      /// in the response will be relative to this given ledger version.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Storage.GetTransactionsResponse GetTransactions(global::Storage.GetTransactionsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetTransactions, null, options, request);
      }
      /// <summary>
      /// When we receive a request from a peer validator asking a list of
      /// transactions for state synchronization, this API can be used to serve the
      /// request. Note that the peer should specify a ledger version and all proofs
      /// in the response will be relative to this given ledger version.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Storage.GetTransactionsResponse> GetTransactionsAsync(global::Storage.GetTransactionsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetTransactionsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// When we receive a request from a peer validator asking a list of
      /// transactions for state synchronization, this API can be used to serve the
      /// request. Note that the peer should specify a ledger version and all proofs
      /// in the response will be relative to this given ledger version.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Storage.GetTransactionsResponse> GetTransactionsAsync(global::Storage.GetTransactionsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetTransactions, null, options, request);
      }
      public virtual global::Storage.GetAccountStateWithProofByStateRootResponse GetAccountStateWithProofByStateRoot(global::Storage.GetAccountStateWithProofByStateRootRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetAccountStateWithProofByStateRoot(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::Storage.GetAccountStateWithProofByStateRootResponse GetAccountStateWithProofByStateRoot(global::Storage.GetAccountStateWithProofByStateRootRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetAccountStateWithProofByStateRoot, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::Storage.GetAccountStateWithProofByStateRootResponse> GetAccountStateWithProofByStateRootAsync(global::Storage.GetAccountStateWithProofByStateRootRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetAccountStateWithProofByStateRootAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::Storage.GetAccountStateWithProofByStateRootResponse> GetAccountStateWithProofByStateRootAsync(global::Storage.GetAccountStateWithProofByStateRootRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetAccountStateWithProofByStateRoot, null, options, request);
      }
      /// <summary>
      /// Returns information needed for Executor to start up.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Storage.GetExecutorStartupInfoResponse GetExecutorStartupInfo(global::Storage.GetExecutorStartupInfoRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetExecutorStartupInfo(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Returns information needed for Executor to start up.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Storage.GetExecutorStartupInfoResponse GetExecutorStartupInfo(global::Storage.GetExecutorStartupInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetExecutorStartupInfo, null, options, request);
      }
      /// <summary>
      /// Returns information needed for Executor to start up.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Storage.GetExecutorStartupInfoResponse> GetExecutorStartupInfoAsync(global::Storage.GetExecutorStartupInfoRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetExecutorStartupInfoAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Returns information needed for Executor to start up.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Storage.GetExecutorStartupInfoResponse> GetExecutorStartupInfoAsync(global::Storage.GetExecutorStartupInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetExecutorStartupInfo, null, options, request);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      protected override StorageClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new StorageClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    public static grpc::ServerServiceDefinition BindService(StorageBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_SaveTransactions, serviceImpl.SaveTransactions)
          .AddMethod(__Method_UpdateToLatestLedger, serviceImpl.UpdateToLatestLedger)
          .AddMethod(__Method_GetTransactions, serviceImpl.GetTransactions)
          .AddMethod(__Method_GetAccountStateWithProofByStateRoot, serviceImpl.GetAccountStateWithProofByStateRoot)
          .AddMethod(__Method_GetExecutorStartupInfo, serviceImpl.GetExecutorStartupInfo).Build();
    }

    /// <summary>Register service method with a service binder with or without implementation. Useful when customizing the  service binding logic.
    /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
    /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    public static void BindService(grpc::ServiceBinderBase serviceBinder, StorageBase serviceImpl)
    {
      serviceBinder.AddMethod(__Method_SaveTransactions, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Storage.SaveTransactionsRequest, global::Storage.SaveTransactionsResponse>(serviceImpl.SaveTransactions));
      serviceBinder.AddMethod(__Method_UpdateToLatestLedger, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Types.UpdateToLatestLedgerRequest, global::Types.UpdateToLatestLedgerResponse>(serviceImpl.UpdateToLatestLedger));
      serviceBinder.AddMethod(__Method_GetTransactions, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Storage.GetTransactionsRequest, global::Storage.GetTransactionsResponse>(serviceImpl.GetTransactions));
      serviceBinder.AddMethod(__Method_GetAccountStateWithProofByStateRoot, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Storage.GetAccountStateWithProofByStateRootRequest, global::Storage.GetAccountStateWithProofByStateRootResponse>(serviceImpl.GetAccountStateWithProofByStateRoot));
      serviceBinder.AddMethod(__Method_GetExecutorStartupInfo, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Storage.GetExecutorStartupInfoRequest, global::Storage.GetExecutorStartupInfoResponse>(serviceImpl.GetExecutorStartupInfo));
    }

  }
}
#endregion
